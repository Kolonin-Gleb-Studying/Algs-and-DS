# https://youtu.be/GOF4VUi4nGU - видео разбор задачи
# 10:20 - восстановление ответа

# Найти длину наибольшей общей последовательности

# lcs - length common sequence
def lcs(s1, s2):
    n = len(s1) # длина 1 последовательности (= Кол. столбцов - 1)
    print("Длина 1 последовательности = n = " + str(n))
    m = len(s2) # длина 2 последовательности (= Кол. строк - 1)
    print("Длина 2 последовательности = m = " + str(m))
    
    # Инициализация массива размера (n + 1) * (m + 1)
    # Размеры увеличины на 1, чтобы алгоритм работал, т.к. там есть действия типа (i - 1) и (j - 1)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    # dp[0][0] = 0 - База и так будет удавлетворяться

    # Восстановление ответа
    p = [[None] * (m + 1) for _ in range(n + 1)]

    print()

    # Красивый вывод матрицы для анализа ответа
    for row in dp:
        print(row)

    print()

    # Перебор элементов последовательностей
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if s1[i - 1] == s2[j - 1]: # Каждый эл. посл. s1 будет сравниваться с всеми эл. посл. s2
                dp[i][j] = dp[i - 1][j - 1] + 1

                # Сохранение вычисления. Какие эл. сравнили и какой из них попал в НОП
                p[i][j] = (i - 1, j - 1, s1[i - 1])
            else:
                # оставляем максимально число из 2х рассмотренных значений #TODO: Почему именно максимальное? Максимизация ответа?
                # TODO: Что необходимо знать, для вычисления dp[i][j] ?
                # dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

                # Новый вариант, для сохранения вычисления.

                if dp[i - 1][j] > dp[i][j - 1]:
                    # dp[i][j] = dp[i - 1][j] # TODO: Разве запись этого значения потом поможет в рассчётах? Быть может это лишняя трата ресурсов?
                    p[i][j] = (i - 1, j, '') # Символы не совпали
                else:
                    # dp[i][j] = dp[i][j - 1] # TODO: Разве запись этого значения потом поможет в рассчётах? Быть может это лишняя трата ресурсов?
                    p[i][j] = (i, j - 1, '') # Символы не совпали

    # Идя из конца в начало находим ответ, какие символы были перебраны для ответа на задачу
    ans = ''
    cur = p[n][m] # тек. положениие в матрице
    while cur is not None:
        ans += cur[2] # Добавление символа в ответ или не добавление, если символы не совпали
        cur = p[cur[0]][cur[1]]

    # Красивый вывод матрицы для анализа ответа
    for row in dp:
        print(row)

    # Восстановление ответа
    for row in p:
        print(row)

    return ans[::-1]

    # Код для вывода длины НОП, когда не восстанавливали сам ответ
    # return dp[n][m]


s1 = "abacaba"
s2 = "abcabc"

# lcs(s1, s2)
print(lcs(s1, s2))
