# https://youtu.be/GOF4VUi4nGU - видео разбор задачи
# 10:20 - восстановление ответа

# Найти длину наибольшей общей последовательности

def show_step(step, dp):
    print("Шаг = " + str(step))
    print()
    # Красивый вывод матрицы для анализа ответа
    for row in dp:
        print(row)
    print()

# lcs - length common sequence
def lcs(s1, s2):
    n = len(s1) # длина 1 последовательности (= Кол. столбцов - 1)
    print("Длина 1 последовательности = n = " + str(n))
    m = len(s2) # длина 2 последовательности (= Кол. строк - 1)
    print("Длина 2 последовательности = m = " + str(m))
    
    # Инициализация массива размера (n + 1) * (m + 1)
    # Размеры увеличины на 1, чтобы алгоритм работал, т.к. там есть действия типа (i - 1) и (j - 1)
    dp = [[0] * (m + 1) for _ in range(n + 1)]
    # dp[0][0] = 0 - База и так будет удавлетворяться

    # Восстановление ответа
    p = [[None] * (m + 1) for _ in range(n + 1)]

    step = 0

    # Перебор элементов последовательностей
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # Для просмотра хода расчётов
            # step += 1
            # show_step(step, dp)

            if s1[i - 1] == s2[j - 1]: # Каждый эл. посл. s1 будет сравниваться с всеми эл. посл. s2
                # Регистрируем нахождение ещё 1 общего эл. последовательностей.
                dp[i][j] = dp[i - 1][j - 1] + 1

                # Сохранение вычисления. Какие эл. сравнили и фиксация найденного совпадения в НОП
                p[i][j] = (i - 1, j - 1, s1[i - 1])
            else:
                # Оставляем максимальную длину уже найденного ранее НОП.
                # Какие эл. сравнили и фиксация отсутствия совпадения в НОП
                # Для этого берём либо значение строкой выше либо предыдущее значение в этой строке. Подробнее см. комментарий 1


                # Простой функцией max() здесь не отделаться, т.к. необходимо ещё и матрицу p заполнять.
                if dp[i - 1][j] > dp[i][j - 1]:
                    dp[i][j] = dp[i - 1][j]  # Сохр. число общих эл. в посл. из строки выше, т.к. раньше уже было найдено совпадение с этим эл. s2
                    p[i][j] = (i - 1, j, '') # Символы не совпали
                else:
                    dp[i][j] = dp[i][j - 1]  # Сохр. число общих эл. в посл. из пред. эл. т.к. раньше не было найдено совпадение с этим эл. s2
                    p[i][j] = (i, j - 1, '') # Символы не совпали

    # Идя из конца в начало находим ответ, какие символы были перебраны для ответа на задачу
    ans = ''
    cur = p[n][m] # тек. положениие в матрице
    while cur is not None: # Пока не обойду всю матрицу
        ans += cur[2] # Извлечение символа, из матрицы в ответ
        cur = p[cur[0]][cur[1]] # Обновление позиции в матрице

    # Матрица восстановления ответа
    # for row in p:
    #     print(row)

    return ans[::-1]

s1 = "abacaba"
s2 = "abcabc"

print(lcs(s1, s2))


# комментарий 1
'''
В строке матрицы dp появляются значения в соответствии с тем,
сколько ОП (общих последовательностей) обнаружено на этой проверке (сравнение i-ого эл. s1 cо всеми эл. s2).

В каждой следующей строке если совпадения эл. нет, то число всё равно может вырасти на 1, т.к. раньше (выше в этом же столбце)
уже было обнаружено совпадение эл.
'''
