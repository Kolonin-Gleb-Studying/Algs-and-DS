# Различная реализация и вывод неориентированного графа в python
# Разными способами

# 1 Способ 
# Неорентированный граф в виде множества вершин и множества кортежей ребер
# Получение смежных вершин
'''

v = {'A', 'B', 'C', 'D'}
e = {('A', 'B'), ('B', 'C'), ('C', 'D')}
# print(v) - множества хранятся в случайном порядке

# # Вывод смежных вершин для каждой вершины
for vertex1 in v:
    adjacent_vertices = [] # Список смежных вершин для текущей вершины
    for vertex2 in v:
        for edge in e:
            if edge == (vertex1, vertex2) or edge == (vertex2, vertex1):
                adjacent_vertices.append(vertex2)
    print(str(vertex1) + ' : ' + str(adjacent_vertices))
# #

'''

# 2 Способ 
# Неорентированный граф в виде множества вершин и матрицы смежностей
# Получение смежных вершин
'''
v = ['A', 'B', 'C', 'D', 'E']
Adjacency_matrix = [
    [0, 1, 0, 0, 1],
    [1, 0, 1, 1, 0],
    [0, 1, 0, 0, 1],
    [0, 1, 0, 0, 1],
    [1, 0, 1, 1, 0],
]

# генератор словаря python
# Содержит пары вершина и индекс её строки/столбца в матрице
indexes = {v[i]: i for i in range(len(v))}

for vertex in v:
    # Список смежных вершин для текущей вершины
    adjacent_vertices = []
    # Чтение матрицы смежности по строкам
    row = Adjacency_matrix[indexes[vertex]]
    for connection_index in range(len(row)):
        if row[connection_index]: # Если присутствует связь
            adjacent_vertices.append(v[connection_index]) # Добавление смежной вершины
    print(vertex, " : ", adjacent_vertices)
'''

# 3 Способ
# Неорентированный граф в виде множества вершин и множества кортежей ребер
# Получение матрицы смежностей графа

v = {'A', 'B', 'C', 'D', 'E'}
e = {('A', 'B'), ('A', 'E'), ('B', 'C'), ('B', 'D'), ('C', 'E'), ('D', 'E')}

# Матрица смежностей будет 6*6 #
# симметрична отн. осн. диаг.  #
Adjacency_matrix = [
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
]

# e = {('A', 'B'), ...
# Получение индекса A (Ai)
# Получение индекса B (Bi)
# Нахождение [Ai][Bi] в матрице запись 1
# Нахождение [Bi][Ai] в матрице запись 1

# Генератор словаря python
# Содержит пары вершина и индекс её строки/столбца в матрице
indexes = {v[i]: i for i in range(len(v))}

for vertex in v:
    # Список смежных вершин для текущей вершины
    adjacent_vertices = []
    # Чтение матрицы смежности по строкам
    row = Adjacency_matrix[indexes[vertex]]
    for connection_index in range(len(row)):
        if row[connection_index]: # Если присутствует связь
            adjacent_vertices.append(v[connection_index]) # Добавление смежной вершины
    print(vertex, " : ", adjacent_vertices)

'''
Для формирования матрицы смежности я буду:
0) Создам матрицу смежности заполненную 0
1) Определю, какие вершины смежны с текущей вершиной.
2) По индексам найду ячейки пересечения.
3) запишу туда 1
'''

'''
Обход в глубину на следующем уроке 

На следующем уроке рекурсия обхода в глубину
'''

